acq <- "Gulf Applied Technologies Inc said it sold its subsidiaries engaged in pipeline and terminal operations for 12.2 mln dlrs. The company said the sale is subject to certain post closing adjustments, which it did not explain. Reuter."
acqTag <- tagPOS(acq)
sapply(strsplit(acqTag,"[[:punct:]]*/VB.?"),function(x) sub("(^.*\\s)(\\w+$)", "\\2", x))
grep("ht(tp(s)*)*", ["HTTPS://", "https://"], ignore.case = TRUE, value = TRUE)
grep("ht(tp(s)*)*", ("HTTPS://", "https://"), ignore.case = TRUE, value = TRUE)
grep("ht(tp(s)*)*", c("HTTPS://", "https://"), ignore.case = TRUE, value = TRUE)
grep("ht(tp(s)*)*", c("HTTPS://", "ht), ignore.case = TRUE, value = TRUE)
grep("ht(tp(s)*)*", c("HTTPS://", "https://"), ignore.case = TRUE, value = TRUE)
grep("ht(tp(s)*)*|(tco)*", c("HTTPS://", "https://", "tco.."), ignore.case = TRUE, value = TRUE)
grep("ht(tp(s)*(://)+)+|(tco)*", c("HTTPS://dasdasdasdas", "https://asdasdasd", "tco.."), ignore.case = TRUE, value = TRUE)
install.packages('caret')
library('caret')
library('rpart')
library('rpart.plot')
install.packages('rpart.plot')
library('rpart.plot')
install.packages('caret')
library('caret')
library('caret')
library('rpart')
library('rpart.plot')
install.packages('caret')
library('caret')
library('rpart')
install.packages('ggplot2')
install.packages('pROC')
install = function(pkg){
# Si ya está instalado, no lo instala.
if (!require(pkg, character.only = TRUE)) {
install.packages(pkg, repos = "http:/cran.rstudio.com")
if (!require(pkg, character.only = TRUE)) stop(paste("load failure:", pkg))
}
}
install("jsonlite")
fetch_data = function(preamble, list){
data = preamble
for(elem in list){
data = paste0(data, paste0(strsplit(elem, " ")[[1]], collapse = "+"), "|", collapse = "")
}
return(substr(data, 0, nchar(data)-1))
}
# Install dependencies in Linux
# sudo apt-get install libcurl4-openssl-dev
install = function(pkg){
# Si ya está instalado, no lo instala.
if (!require(pkg, character.only = TRUE)) {
install.packages(pkg, repos = "http:/cran.rstudio.com")
if (!require(pkg, character.only = TRUE)) stop(paste("load failure:", pkg))
}
}
install("jsonlite")
fetch_data = function(preamble, list){
data = preamble
for(elem in list){
data = paste0(data, paste0(strsplit(elem, " ")[[1]], collapse = "+"), "|", collapse = "")
}
return(substr(data, 0, nchar(data)-1))
}
get_url = function(origins, destinations, key, mode = "driving", language = "es"){
# install(pkg)
# url base for distance matrix api
base = "https://maps.googleapis.com/maps/api/distancematrix/json?"
# This could change, using only some atributes from API
origin = fetch_data("origins=", origins)
destination = fetch_data("destinations=", destinations)
key = fetch_data("key=", key)
mode = fetch_data("mode=", mode)
language = fetch_data("language=", language)
# Getting final format for Google API
api_url = paste(c(base, paste0(c(origin, destination, key, mode, language), collapse = "&")), collapse = "")
return(api_url)
}
get_data = function(api_url){
return(fromJSON(api_url))
}
# To Complete
parse_data = function(json){
}
?confusion.matrix
?confusionMatrix
setwd("~/Desktop/univ/Minería de Datos/Tareas/Tarea_3/AprendizajeNoSupervisado")
a <- read.csv("a.csv")
names(a)[1] <- "x"
names(a)[2] <- "y"
names(a)[3] <- "class"
## Hcluster
hclust_methods <- c("ward.D", "single", "complete", "average", "mcquitty", "median", "centroid", "ward.D2")
dist_methods <- c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski")
a.num <- a # a copy of the dataframe
a.num$class <-NULL # Delete class column
a.num <- as.matrix(a.num) # convert into a matrix
better.accuracy <- 0
for (i in 1:length(dist_methods)){
for (j in 1:length(hclust_methods)){
a.dist.mat <- dist(a.num, method = dist_methods[i]) # distance matrix
a.cluster <- hclust(a.dist.mat, method = hclust_methods[j]) # apply method
ct <- cutree(a.cluster, k =3) # k to generate 3 clusters
confusion.Matrix <- table(as.factor(a$class), as.factor(ct))
accuracy.CM <- sum(diag(confusion.Matrix))/sum(confusion.Matrix)
if (accuracy.CM > better.accuracy){
better.methods <- c(dist_methods[i], hclust_methods[j])
better.accuracy <- accuracy.CM
}
}
}
?t
a.dist.mat <- dist(a.num, method = dist_methods[4]) # distance matrix
dist_methods[4]
a.cluster <- hclust(a.dist.mat, method = hclust_methods[1]) # apply method
hclust(a.dist.mat, method = hclust_methods[1])
?hclust
?dist
dist_methods <- c("euclidean", "maximum", "manhattan", "binary", "minkowski")
a.dist.mat <- dist(a.num, method = dist_methods[4]) # distance matrix
dist_methods[4]
a.cluster <- hclust(a.dist.mat, method = hclust_methods[1]) # apply method
a.cluster
ct <- cutree(a.cluster, k =3) # k to generate 3 clusters
confusion.Matrix <- table(as.factor(a$class), as.factor(ct))
accuracy.CM <- sum(diag(confusion.Matrix))/sum(confusion.Matrix)
accuracy.CM
dist_methods <- c("euclidean", "maximum", "manhattan", "binary", "minkowski")
for (i in 1:length(dist_methods)){
for (j in 1:length(hclust_methods)){
a.dist.mat <- dist(a.num, method = dist_methods[i]) # distance matrix
a.cluster <- hclust(a.dist.mat, method = hclust_methods[j]) # apply method
ct <- cutree(a.cluster, k =3) # k to generate 3 clusters
confusion.Matrix <- table(as.factor(a$class), as.factor(ct))
accuracy.CM <- sum(diag(confusion.Matrix))/sum(confusion.Matrix)
if (accuracy.CM > better.accuracy){
better.methods <- c(dist_methods[i], hclust_methods[j])
better.accuracy <- accuracy.CM
}
}
}
better.methods
better.accuracy
# install.packages("clue")
library("stringr")
library("caret")
a <- read.csv("a.csv")
names(a)[1] <- "x"
names(a)[2] <- "y"
names(a)[3] <- "class"
a.hclust_methods <- c("ward.D", "single", "complete", "average", "mcquitty", "median", "centroid", "ward.D2")
a.dist_methods <- c("euclidean", "maximum", "manhattan", "binary", "minkowski")
a.better.accuracy <- 0
for (i in 1:length(dist_methods)){
for (j in 1:length(hclust_methods)){
a.dist.mat <- dist(a.num, method = dist_methods[i]) # distance matrix
a.cluster <- hclust(a.dist.mat, method = hclust_methods[j]) # apply method
ct <- cutree(a.cluster, k =3) # k to generate 3 clusters
a.confusion.Matrix <- table(as.factor(a$class), as.factor(ct))
a.accuracy.CM <- sum(diag(confusion.Matrix))/sum(confusion.Matrix)
if (accuracy.CM > better.accuracy){
a.better.methods <- c(dist_methods[i], hclust_methods[j])
a.hclust.better.accuracy <- accuracy.CM
}
}
}
for (i in 1:length(a.dist_methods)){
for (j in 1:length(a.hclust_methods)){
a.dist.mat <- dist(a.num, method = a.dist_methods[i]) # distance matrix
a.cluster <- hclust(a.dist.mat, method = a.hclust_methods[j]) # apply method
ct <- cutree(a.cluster, k =3) # k to generate 3 clusters
a.confusion.Matrix <- table(as.factor(a$class), as.factor(ct))
a.accuracy.CM <- sum(diag(a.confusion.Matrix))/sum(a.confusion.Matrix)
if (accuracy.CM > a.better.accuracy){
a.better.methods <- c(a.dist_methods[i], a.hclust_methods[j])
a.hclust.better.accuracy <- accuracy.CM
}
}
}
a.num <- a # a copy of the dataframe
a.num$class <-NULL # Delete class column
a.num <- as.matrix(a.num) # convert into a matrix
a.better.accuracy <- 0
for (i in 1:length(a.dist_methods)){
for (j in 1:length(a.hclust_methods)){
a.dist.mat <- dist(a.num, method = a.dist_methods[i]) # distance matrix
a.cluster <- hclust(a.dist.mat, method = a.hclust_methods[j]) # apply method
ct <- cutree(a.cluster, k =3) # k to generate 3 clusters
a.confusion.Matrix <- table(as.factor(a$class), as.factor(ct))
a.accuracy.CM <- sum(diag(a.confusion.Matrix))/sum(a.confusion.Matrix)
if (accuracy.CM > a.better.accuracy){
a.better.methods <- c(a.dist_methods[i], a.hclust_methods[j])
a.hclust.better.accuracy <- accuracy.CM
}
}
}
a.better.accuracy <- 0
for (i in 1:length(a.dist_methods)){
for (j in 1:length(a.hclust_methods)){
a.dist.mat <- dist(a.num, method = a.dist_methods[i]) # distance matrix
a.cluster <- hclust(a.dist.mat, method = a.hclust_methods[j]) # apply method
ct <- cutree(a.cluster, k =3) # k to generate 3 clusters
a.confusion.Matrix <- table(as.factor(a$class), as.factor(ct))
a.accuracy.CM <- sum(diag(a.confusion.Matrix))/sum(a.confusion.Matrix)
if (a.accuracy.CM > a.better.accuracy){
a.better.methods <- c(a.dist_methods[i], a.hclust_methods[j])
a.hclust.better.accuracy <- accuracy.CM
}
}
}
for (i in 1:length(a.dist_methods)){
for (j in 1:length(a.hclust_methods)){
a.dist.mat <- dist(a.num, method = a.dist_methods[i]) # distance matrix
a.cluster <- hclust(a.dist.mat, method = a.hclust_methods[j]) # apply method
ct <- cutree(a.cluster, k =3) # k to generate 3 clusters
a.confusion.Matrix <- table(as.factor(a$class), as.factor(ct))
a.accuracy.CM <- sum(diag(a.confusion.Matrix))/sum(a.confusion.Matrix)
if (a.accuracy.CM > a.better.accuracy){
a.better.methods <- c(a.dist_methods[i], a.hclust_methods[j])
a.hclust.better.accuracy <- a.accuracy.CM
}
}
}
a.better.methods
a.hclust.better.accuracy
a.dist.mat <- dist(a.num, method = a.dist_methods[3]) # distance matrix
a.cluster <- hclust(a.dist.mat, method = a.hclust_methods[5]) # apply method
ct <- cutree(a.cluster, k =3) # k to generate 3 clusters
a.confusion.Matrix <- table(as.factor(a$class), as.factor(ct))
a.accuracy.CM <- sum(diag(a.confusion.Matrix))/sum(a.confusion.Matrix)
a.accuracy.CM
a.accuracy.CM > a.better.accuracy
a.better.accuracy <- 0
for (i in 1:length(a.dist_methods)){
for (j in 1:length(a.hclust_methods)){
a.dist.mat <- dist(a.num, method = a.dist_methods[i]) # distance matrix
a.cluster <- hclust(a.dist.mat, method = a.hclust_methods[j]) # apply method
ct <- cutree(a.cluster, k =3) # k to generate 3 clusters
a.confusion.Matrix <- table(as.factor(a$class), as.factor(ct))
a.accuracy.CM <- sum(diag(a.confusion.Matrix))/sum(a.confusion.Matrix)
if (a.accuracy.CM > a.better.accuracy){
a.better.methods <- c(a.dist_methods[i], a.hclust_methods[j])
a.hclust.better.accuracy <- a.accuracy.CM
}
}
}
a.hclust_methods <- c("ward.D", "single", "complete", "average", "mcquitty", "median", "centroid", "ward.D2")
a.dist_methods <- c("euclidean", "maximum", "manhattan", "binary", "minkowski")
a.num <- a # a copy of the dataframe
a.num$class <-NULL # Delete class column
a.num <- as.matrix(a.num) # convert into a matrix
# Calculating each distance method vs each hclust method
a.better.accuracy <- 0
for (i in 1:length(a.dist_methods)){
for (j in 1:length(a.hclust_methods)){
a.dist.mat <- dist(a.num, method = a.dist_methods[i]) # distance matrix
a.cluster <- hclust(a.dist.mat, method = a.hclust_methods[j]) # apply method
ct <- cutree(a.cluster, k =3) # k to generate 3 clusters
a.confusion.Matrix <- table(as.factor(a$class), as.factor(ct))
a.accuracy.CM <- sum(diag(a.confusion.Matrix))/sum(a.confusion.Matrix)
if (a.accuracy.CM > a.better.accuracy){
a.better.methods <- c(a.dist_methods[i], a.hclust_methods[j])
a.hclust.better.accuracy <- a.accuracy.CM
}
}
}
library("stringr")
library("caret")
a <- read.csv("a.csv")
names(a)[1] <- "x"
names(a)[2] <- "y"
names(a)[3] <- "class"
a.hclust_methods <- c("ward.D", "single", "complete", "average", "mcquitty", "median", "centroid", "ward.D2")
a.dist_methods <- c("euclidean", "maximum", "manhattan", "binary", "minkowski")
a.num <- a # a copy of the dataframe
a.num$class <-NULL # Delete class column
a.num <- as.matrix(a.num) # convert into a matrix
a.hclust.better.accuracy <- 0
for (i in 1:length(a.dist_methods)){
for (j in 1:length(a.hclust_methods)){
a.dist.mat <- dist(a.num, method = a.dist_methods[i]) # distance matrix
a.cluster <- hclust(a.dist.mat, method = a.hclust_methods[j]) # apply method
ct <- cutree(a.cluster, k =3) # k to generate 3 clusters
a.confusion.Matrix <- table(as.factor(a$class), as.factor(ct))
a.accuracy.CM <- sum(diag(a.confusion.Matrix))/sum(a.confusion.Matrix)
if (a.accuracy.CM > a.hclust.better.accuracy){
a.better.methods <- c(a.dist_methods[i], a.hclust_methods[j])
a.hclust.better.accuracy <- a.accuracy.CM
}
}
}
a.kmeans <- kmeans(a[,1:2], centers = 3)
plot(a$x, a$y, col= a.kmeans$cluster)
points(a.kmeans$centers[, c("x", "y")],
col=1:3,
pch = 19,
cex = 2)
table(a.kmeans$cluster, a$class)
a.kmeans.confusion.Matrix <- table(a.kmeans$cluster, a$class)
a.kmeans.confusion.Matrix
a.kmeans.accuracy.CM <- sum(diag(a.kmeans.confusion.Matrix))/sum(a.kmeans.confusion.Matrix)
a.kmeans.accuracy.CM
class(a.kmeans$cluster)
head(a.kmeans$cluster)
head(a$class)
plot(a$x, a$y, col=1:3)
plot(a$x, a$y, col=a$class)
plot(a$x, a$y, col=1:3)
a.kmeans <- kmeans(a[,1:2], centers = 3)
plot(a$x, a$y, col= a.kmeans$cluster)
points(a.kmeans$centers[, c("x", "y")],
col=1:3,
pch = 19,
cex = 3)
a.kmeans.confusion.Matrix <- table(a.kmeans$cluster, a$class)
a.kmeans.accuracy.CM <- sum(diag(a.kmeans.confusion.Matrix))/sum(a.kmeans.confusion.Matrix)
a.kmeans.accuracy.CM
a.pam <- pam(a[,1:2], 3)
library("stringr")
library("caret")
a.pam <- pam(a[,1:2], 3)
library("clue")
a.pam <- pam(a[,1:2], 3)
?pam
library("cluster")
a.pam <- pam(a[,1:2], 3)
plot(a$x, a$y, col = a.pam$clustering)
points(a.pam$medoids,
col=1:3,
pch = 18,
cex = 3)
a.pam.confusion.Matrix <- table(a.pam$medoids, a$class)
a.pam.confusion.Matrix <- table(a.pam$clustering, a$class)
a.pam.confusion.Matrix
a.pam.accuracy.CM <- sum(diag(a.pam.confusion.Matrix))/sum(a.pam.confusion.Matrix)
a.pam.accuracy.CM
a.kmeans.accuracy.CM
plot(a$x, a$y, col= a.kmeans$cluster)
points(a.kmeans$centers[, c("x", "y")],
col=1:3,
pch = 19,
cex = 3)
if (a.kmeans.accuracy.CM > a.pam.accuracy.CM){
kmeans.vs.pam <- a.kmeans.accuracy.CM
}
if (a.kmeans.accuracy.CM < a.pam.accuracy.CM){
kmeans.vs.pam <- a.pam.accuracy.CM
}
if (a.kmeans.accuracy.CM == a.pam.accuracy.CM){
kmeans.vs.pam <- a.kmeans.accuracy.CM
}
kmeans.vs.pam
a.hclust.better.accuracy
if (a.hclust.better.accuracy > kmeans.vs.pam){
final.cluster <- a.hclust.better.accuracy
}
if (a.hclust.better.accuracy < kmeans.vs.pam || a.hclust.better.accuracy == kmeans.vs.pam){
final.cluster <- kmeans.vs.pam
}
final.cluster
a.better.methods
a.better.methods[1]
a.better.methods[2]
a.better.methods[1]
a.dist.mat <- dist(a.num, method = a.better.methods[1]) # distance matrix
a.better.methods[2]
a.cluster <- hclust(a.dist.mat, method = a.better.methods[2]) # apply method
plot(a.cluster) # dendrogram
plot(a$x, a$y, col= a.ct)
a.ct <- cutree(a.cluster, k =3) # k to generate 3 clusters
plot(a$x, a$y, col= a.ct)
library("stringr")
library("caret")
library("clue")
library("cluster")
a <- read.csv("a.csv")
names(a)[1] <- "x"
names(a)[2] <- "y"
names(a)[3] <- "class"
a.kmeans <- kmeans(a[,1:2], centers = 3)
a.kmeans.confusion.Matrix <- table(a.kmeans$cluster, a$class)
a.kmeans.accuracy.CM <- sum(diag(a.kmeans.confusion.Matrix))/sum(a.kmeans.confusion.Matrix)
a.kmeans <- kmeans(a[,1:2], centers = 3)
a.kmeans.confusion.Matrix <- table(a.kmeans$cluster, a$class)
a.kmeans.accuracy.CM <- sum(diag(a.kmeans.confusion.Matrix))/sum(a.kmeans.confusion.Matrix)
a.kmeans <- kmeans(a[,1:2], centers = 3)
a.kmeans.confusion.Matrix <- table(a.kmeans$cluster, a$class)
a.kmeans.accuracy.CM <- sum(diag(a.kmeans.confusion.Matrix))/sum(a.kmeans.confusion.Matrix)
a.kmeans <- kmeans(a[,1:2], centers = 3)
a.kmeans.confusion.Matrix <- table(a.kmeans$cluster, a$class)
a.kmeans.accuracy.CM <- sum(diag(a.kmeans.confusion.Matrix))/sum(a.kmeans.confusion.Matrix)
a.kmeans <- kmeans(a[,1:2], centers = 3)
a.kmeans.confusion.Matrix <- table(a.kmeans$cluster, a$class)
a.kmeans.accuracy.CM <- sum(diag(a.kmeans.confusion.Matrix))/sum(a.kmeans.confusion.Matrix)
a.kmeans <- kmeans(a[,1:2], centers = 3)
a.kmeans.confusion.Matrix <- table(a.kmeans$cluster, a$class)
a.kmeans.accuracy.CM <- sum(diag(a.kmeans.confusion.Matrix))/sum(a.kmeans.confusion.Matrix)
a.kmeans <- kmeans(a[,1:2], centers = 3)
a.kmeans.confusion.Matrix <- table(a.kmeans$cluster, a$class)
a.kmeans.accuracy.CM <- sum(diag(a.kmeans.confusion.Matrix))/sum(a.kmeans.confusion.Matrix)
a.kmeans <- kmeans(a[,1:2], centers = 3)
a.kmeans.confusion.Matrix <- table(a.kmeans$cluster, a$class)
a.kmeans.accuracy.CM <- sum(diag(a.kmeans.confusion.Matrix))/sum(a.kmeans.confusion.Matrix)
a.kmeans <- kmeans(a[,1:2], centers = 3)
a.kmeans.confusion.Matrix <- table(a.kmeans$cluster, a$class)
a.kmeans.accuracy.CM <- sum(diag(a.kmeans.confusion.Matrix))/sum(a.kmeans.confusion.Matrix)
a.kmeans <- kmeans(a[,1:2], centers = 3)
a.kmeans.confusion.Matrix <- table(a.kmeans$cluster, a$class)
a.kmeans.accuracy.CM <- sum(diag(a.kmeans.confusion.Matrix))/sum(a.kmeans.confusion.Matrix)
a.kmeans <- kmeans(a[,1:2], centers = 3)
a.kmeans.confusion.Matrix <- table(a.kmeans$cluster, a$class)
a.kmeans.accuracy.CM <- sum(diag(a.kmeans.confusion.Matrix))/sum(a.kmeans.confusion.Matrix)
a.pam <- pam(a[,1:2], 3)
a.pam.confusion.Matrix <- table(a.pam$clustering, a$class)
a.pam.accuracy.CM <- sum(diag(a.pam.confusion.Matrix))/sum(a.pam.confusion.Matrix)
if (a.kmeans.accuracy.CM >= a.pam.accuracy.CM){
kmeans.vs.pam <- a.kmeans.accuracy.CM
kmeans.vs.pam.choose <- c("kmeans")
}else{
kmeans.vs.pam <- a.pam.accuracy.CM
kmeans.vs.pam.choose <- c("pam")
}
a.hclust_methods <- c("ward.D", "single", "complete", "average", "mcquitty", "median", "centroid", "ward.D2")
a.dist_methods <- c("euclidean", "maximum", "manhattan", "binary", "minkowski")
a.num <- a # a copy of the dataframe
a.num$class <-NULL # Delete class column
a.num <- as.matrix(a.num) # convert into a matrix
a.hclust.better.accuracy <- 0
for (i in 1:length(a.dist_methods)){
for (j in 1:length(a.hclust_methods)){
a.dist.mat <- dist(a.num, method = a.dist_methods[i]) # distance matrix
a.cluster <- hclust(a.dist.mat, method = a.hclust_methods[j]) # apply method
ct <- cutree(a.cluster, k =3) # k to generate 3 clusters
a.hclust.confusion.Matrix <- table(as.factor(a$class), as.factor(ct))
a.hclust.accuracy.CM <- sum(diag(a.hclust.confusion.Matrix))/sum(a.hclust.confusion.Matrix)
if (a.hclust.accuracy.CM > a.hclust.better.accuracy){
a.better.methods <- c(a.dist_methods[i], a.hclust_methods[j])
a.hclust.better.accuracy <- a.hclust.accuracy.CM
}
}
}
a.hclust.better.accuracy
if (a.hclust.better.accuracy > kmeans.vs.pam){
final.cluster <- a.hclust.better.accuracy
a.dist.mat <- dist(a.num, method = a.better.methods[1]) # distance matrix
a.cluster <- hclust(a.dist.mat, method = a.better.methods[2]) # apply method
a.ct <- cutree(a.cluster, k =3) # k to generate 3 clusters
plot(a.cluster) # dendrogram
plot(a$x, a$y, col= a.ct)
}
if (a.hclust.better.accuracy < kmeans.vs.pam || a.hclust.better.accuracy == kmeans.vs.pam){
final.cluster <- kmeans.vs.pam
if (kmeans.vs.pam.choose[1] == 'pam'){
plot(a$x, a$y, col = a.pam$clustering)
points(a.pam$medoids,
col=1:3,
pch = 18,
cex = 3)
}else{
plot(a$x, a$y, col= a.kmeans$cluster)
points(a.kmeans$centers[, c("x", "y")],
col=1:3,
pch = 19,
cex = 3)
}
}
a.hclust.better.accuracy > kmeans.vs.pam
if (a.hclust.better.accuracy > kmeans.vs.pam){
final.cluster <- a.hclust.better.accuracy
a.dist.mat <- dist(a.num, method = a.better.methods[1]) # distance matrix
a.cluster <- hclust(a.dist.mat, method = a.better.methods[2]) # apply method
a.ct <- cutree(a.cluster, k =3) # k to generate 3 clusters
plot(a.cluster) # dendrogram
plot(a$x, a$y, col= a.ct)
}else{
final.cluster <- kmeans.vs.pam
if (kmeans.vs.pam.choose[1] == 'pam'){
plot(a$x, a$y, col = a.pam$clustering)
points(a.pam$medoids,
col=1:3,
pch = 18,
cex = 3)
}else{
plot(a$x, a$y, col= a.kmeans$cluster)
points(a.kmeans$centers[, c("x", "y")],
col=1:3,
pch = 19,
cex = 3)
}
}
final.cluster
kmeans.vs.pam.choose[1]
kmeans.vs.pam.choose[1] == 'pam'
plot(a$x, a$y, col = a.pam$clustering, main = "PAM")
rect.hclust(a.cluster, k = 3, border = c("cyan"))
plot(a.cluster) # dendrogram
rect.hclust(a.cluster, k = 3, border = c("cyan"))
corte <- cut(a.cluster, h=100)$upper
class(a.ct)
final.cluster <- a.hclust.better.accuracy
a.dist.mat <- dist(a.num, method = a.better.methods[1]) # distance matrix
a.cluster <- hclust(a.dist.mat, method = a.better.methods[2]) # apply method
a.ct <- cutree(a.cluster, k =3) # k to generate 3 clusters
class(a.ct)
class(a.cluster)
corte <- cut(a.ct, h=100)$upper
dendrogram <- as.dendrogram(a.cluster)
corte <- cut(dendrogram, h=100)$upper
plot(corte)
corte <- cut(dendrogram, h=80)$upper
plot(corte)
corte <- cut(dendrogram, h=200)$upper
plot(corte)
dendrogram <- as.dendrogram(a.cluster)
dendrogram
plot(dendrogram)
corte <- cut(dendrogram, h=20)$upper
plot(corte)
